import asyncio
import json
import os
from typing import Dict, List, Any, Optional
from loguru import logger
from server.config import CONFIG_MAIN_FILE_PATH


class ToolManager:
    """
    Service for managing external tools as subprocesses.
    Handles tool lifecycle (start, stop, reload) and communication via stdin/stdout.
    """

    def __init__(self, config_path: str = CONFIG_MAIN_FILE_PATH):
        # Use environment variable for config path if not provided
        self.config_path = config_path
        self.tools: Dict[str, Dict[str, Any]] = {}  # Store tool metadata and process objects
        self.config: Dict[str, Any] = {}

    async def initialize(self):
        """Initialize the tool manager by loading config and starting all tools."""
        logger.info(f"Initializing ToolManager with config from: {self.config_path}")
        try:
            # Load configuration
            await self.load_config()

            # Initialize and start all tools
            await self.start_all_tools()

            logger.info("ToolManager initialization completed successfully")
        except Exception as e:
            logger.error(f"Failed to initialize ToolManager: {str(e)}")
            raise

    async def load_config(self):
        """Load tool configuration from the config file."""
        logger.info(f"Loading tool configuration from {self.config_path}")
        try:
            with open(self.config_path, "r", encoding="utf-8") as config_file:
                self.config = json.load(config_file)
            logger.info(f"Loaded configuration with {len(self.config.get('mcpServers', []))} tools defined")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.error(f"Error loading config: {str(e)}")
            self.config = {"mcpServers": {}}

    async def save_config(self):
        """Save current configuration to the config file."""
        try:
            with open(self.config_path, "w", encoding="utf-8") as config_file:
                json.dump(self.config, config_file, indent=4)
        except Exception as e:
            logger.error(f"Error saving config: {str(e)}")

    async def start_all_tools(self):
        """Start all tools defined in the configuration."""
        logger.info("Starting all tools")
        if "mcpServers" in self.config:
            for tool_name, tool_config in self.config["mcpServers"].items():
                try:
                    await self.add_tool(tool_name, tool_config["command"], tool_config["args"])
                    logger.info(f"Successfully initialized tool: {tool_name}")
                except Exception as e:
                    logger.error(f"Failed to start tool {tool_name}: {str(e)}")

    async def add_tool(self, name: str, command: str, args: List[str]) -> Dict[str, Any]:
        """
        Add and start a new tool subprocess.

        Args:
            name: The name of the tool
            command: The command to execute
            args: Command line arguments

        Returns:
            Tool metadata including status
        """
        logger.info(f"Adding tool: {name} with command: {command} {' '.join(args)}")
        # Check if tool already exists
        if name in self.tools:
            return {"status": "error", "message": f"Tool '{name}' already exists"}

        try:
            # Replace 'uvx' with 'uv' and handle different command formats
            final_command = command
            final_args = args.copy()

            if command == "uvx":
                final_command = "uv"

                if len(args) > 0:
                    # Case 1: uvx pip install <module> -> uv pip install <module>
                    if args[0] == "pip" and len(args) > 1 and args[1] == "install":
                        final_args = args  # Keep args the same, just change command from uvx to uv
                        logger.info(f"Converting command for {name}: 'uvx {' '.join(args)}' to 'uv {' '.join(final_args)}'")

                    # Case 2: uvx run <module> [args] -> uv run <module> -- [args]
                    elif args[0] == "run" and len(args) > 1:
                        module_name = args[1]
                        if len(args) > 2:
                            # If there are arguments after the module name, add -- before them
                            final_args = ["run", module_name, "--"] + args[2:]
                        else:
                            # If there are no arguments after the module name
                            final_args = ["run", module_name]
                        logger.info(f"Converting command for {name}: 'uvx {' '.join(args)}' to 'uv {' '.join(final_args)}'")

                    # Case 3: uvx <module> [args] -> uv run <module> -- [args]
                    # This handles the case in config.json where 'run' is not included
                    else:
                        module_name = args[0]
                        if len(args) > 1:
                            # If there are arguments after the module name, add -- before them
                            final_args = ["run", module_name] + args[1:]
                        else:
                            # If there are no arguments after the module name
                            final_args = ["run", module_name]
                        logger.info(f"Converting command for {name}: 'uvx {' '.join(args)}' to 'uv {' '.join(final_args)}'")

            # Get subprocess stream limit from env, default 5MB
            stream_limit = int(os.getenv("SUBPROCESS_STREAM_LIMIT", str(5 * 1024 * 1024)))

            # Start the subprocess
            process = await asyncio.create_subprocess_exec(
                final_command,
                *final_args,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                limit=stream_limit
            )

            # Store tool metadata and process
            self.tools[name] = {
                "name": name,
                "command": command,  # Store original command for config
                "args": args,        # Store original args for config
                "process": process,
                "description": f"{name} tool",
                "input_schema": {},
                "sub_tools": [],
                "status": "initializing"
            }

            # Fetch metadata from the MCP server
            metadata_result = await self.fetch_tool_metadata(name)

            if metadata_result["status"] == "success":
                logger.info(f"Successfully fetched metadata for tool: {name}")
                self.tools[name]["status"] = "running"
            else:
                logger.warning(f"Failed to fetch metadata for tool: {name}. Using default metadata.")
                self.tools[name]["status"] = "running_without_metadata"

            # Update config
            if "mcpServers" not in self.config:
                self.config["mcpServers"] = {}
            self.config["mcpServers"][name] = {
                "command": command,  # Keep original command in config
                "args": args         # Keep original args in config
            }
            await self.save_config()

            return {
                "status": "success",
                "message": f"Tool '{name}' added successfully",
                "metadata": {
                    "name": name,
                    "description": self.tools[name].get("description", ""),
                    "input_schema": self.tools[name].get("input_schema", {}),
                    "sub_tools": self.tools[name].get("sub_tools", []),
                    "status": self.tools[name].get("status", "unknown")
                }
            }

        except Exception as e:
            logger.error(f"Failed to add tool {name}: {str(e)}")
            return {"status": "error", "message": f"Failed to add tool: {str(e)}"}

    async def fetch_tool_metadata(self, name: str) -> Dict[str, Any]:
        """
        Fetch metadata from an MCP server using the tools/list protocol.

        Args:
            name: The name of the tool to fetch metadata for

        Returns:
            Dictionary with status and metadata if successful
        """
        logger.info(f"Fetching metadata for tool: {name}")
        if name not in self.tools:
            return {"status": "error", "message": f"Tool '{name}' not found"}

        try:
            tool = self.tools[name]
            process = tool["process"]

            # Check if the process is still running
            if process.returncode is not None:
                return {"status": "error", "message": "Tool process not running"}

            # First, send the initialized notification according to MCP protocol
            init_request = {
                "jsonrpc": "2.0",
                "method": "notifications/initialized"
            }

            # Send initialization notification
            init_request_str = json.dumps(init_request) + "\n"
            logger.debug(f"Sending initialization notification to {name}: {str(init_request_str)}")
            process.stdin.write(init_request_str.encode())
            await process.stdin.drain()

            # Wait a moment for the server to process the initialization
            await asyncio.sleep(0.5)

            # Prepare tools/list request according to MCP protocol
            request = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "tools/list",
                "params": {}
            }

            # Send request to stdin
            request_str = json.dumps(request) + "\n"
            logger.debug(f"Sending tools/list request to {name}: {str(request_str)}")
            process.stdin.write(request_str.encode())
            await process.stdin.drain()

            # Read response from stdout
            response_line = await process.stdout.readline()

            if not response_line:
                return {"status": "error", "message": "Empty response from tool"}

            # Parse JSON response
            try:
                response = json.loads(response_line)

                # Check if response is valid
                if "jsonrpc" not in response or "result" not in response:
                    return {"status": "error", "message": "Invalid JSON-RPC response"}
                else:
                    logger.debug(f"Received response from {name}:\n{json.dumps(response, indent=4)}")

                # Extract tools from response
                tools_data = response.get("result", {}).get("tools", [])
                next_cursor = response.get("result", {}).get("nextCursor")

                # Handle pagination if needed
                while next_cursor:
                    # Prepare next request with cursor
                    cursor_request = {
                        "jsonrpc": "2.0",
                        "id": 1,
                        "method": "tools/list",
                        "params": {"cursor": next_cursor}
                    }

                    # Send request
                    cursor_request_str = json.dumps(cursor_request) + "\n"
                    logger.debug(f"Sending paginated tools/list request to {name}: {str(cursor_request_str)}")
                    process.stdin.write(cursor_request_str.encode())
                    await process.stdin.drain()

                    # Read response
                    cursor_response_line = await process.stdout.readline()

                    if not cursor_response_line:
                        break

                    # Parse response
                    cursor_response = json.loads(cursor_response_line)

                    # Add tools to the list
                    cursor_tools = cursor_response.get("result", {}).get("tools", [])
                    tools_data.extend(cursor_tools)

                    # Update cursor
                    next_cursor = cursor_response.get("result", {}).get("nextCursor")

                # Update tool metadata
                if tools_data:
                    # If this is a composite tool with sub-tools
                    if len(tools_data) > 1:
                        # Store all sub-tools
                        self.tools[name]["sub_tools"] = tools_data

                        # Use the first tool's description as the parent description
                        # or combine descriptions if needed
                        self.tools[name]["description"] = tools_data[0].get("description", f"{name} tool")

                    else:
                        # Single tool
                        tool_data = tools_data[0]
                        self.tools[name]["description"] = tool_data.get("description", f"{name} tool")
                        self.tools[name]["input_schema"] = tool_data.get("inputSchema", {})

                return {
                    "status": "success",
                    "tools": tools_data
                }

            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON response from {name}: {str(e)}")
                return {"status": "error", "message": f"Invalid JSON response: {str(e)}"}

        except Exception as e:
            logger.error(f"Failed to fetch metadata for tool {name}: {str(e)}")
            return {"status": "error", "message": f"Failed to fetch metadata: {str(e)}"}

    async def remove_tool(self, name: str) -> Dict[str, Any]:
        """
        Stop and remove a tool.

        Args:
            name: The name of the tool to remove

        Returns:
            Status of the operation
        """
        logger.info(f"Removing tool: {name}")
        if name not in self.tools:
            logger.warning(f"Tool '{name}' not found")
            return {"status": "error", "message": f"Tool '{name}' not found"}

        try:
            # Terminate the process
            process = self.tools[name]["process"]
            process.terminate()
            try:
                await asyncio.wait_for(process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                process.kill()  # Force kill if termination takes too long

            # Remove from tools dict
            del self.tools[name]

            # Update config
            if "mcpServers" in self.config and name in self.config["mcpServers"]:
                del self.config["mcpServers"][name]
                await self.save_config()

            logger.info(f"Tool {name} removed successfully")
            return {"status": "success", "message": f"Tool '{name}' removed"}

        except Exception as e:
            logger.error(f"Failed to remove tool {name}: {str(e)}")
            return {"status": "error", "message": f"Failed to remove tool: {str(e)}"}

    async def reload_tool(self, name: str) -> Dict[str, Any]:
        """
        Reload (restart) a specific tool.

        Args:
            name: The name of the tool to reload

        Returns:
            Status of the operation
        """
        logger.info(f"Reloading tool: {name}")
        if name not in self.tools:
            logger.warning(f"Tool '{name}' not found")
            return {"status": "error", "message": f"Tool '{name}' not found"}

        try:
            # Store current configuration
            command = self.tools[name]["command"]
            args = self.tools[name]["args"]

            # Remove the tool
            await self.remove_tool(name)

            # Add it back with the same configuration
            result = await self.add_tool(name, command, args)

            if "status" in result and result["status"] == "error":
                return result

            logger.info(f"Tool {name} reloaded successfully")
            return {"status": "success", "message": f"Tool '{name}' reloaded"}

        except Exception as e:
            logger.error(f"Failed to reload tool {name}: {str(e)}")
            return {"status": "error", "message": f"Failed to reload tool: {str(e)}"}

    async def list_tools(self) -> List[Dict[str, Any]]:
        """
        List all tools with their metadata.

        Returns:
            List of tool metadata
        """
        logger.debug("Listing all tools")
        result = []
        for name, tool in self.tools.items():
            # Check if process is still running
            if tool["process"].returncode is not None:
                tool["status"] = "stopped"

            # Prepare tool metadata
            tool_metadata = {
                "name": name,
                "description": tool.get("description", ""),
                "input_schema": tool.get("input_schema", {}),
                "status": tool.get("status", "unknown")
            }
            sub_tools = tool.get("sub_tools", [])
            if sub_tools:
                tool_metadata["sub_tools"] = sub_tools
            result.append(tool_metadata)

        return result

    async def invoke_tool(self, name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Send a request to a tool and get its response.

        Args:
            name: The name of the tool to invoke
            params: Parameters to send to the tool

        Returns:
            Tool response or error
        """
        logger.info(f"Invoking tool: {name} with params: {params}")
        if name not in self.tools:
            logger.warning(f"Tool '{name}' not found")
            return {"status": "error", "message": f"Tool '{name}' not found"}

        try:
            tool = self.tools[name]
            process = tool["process"]

            # Check if the process is still running
            if process.returncode is not None:
                # Try to restart the tool
                command = tool["command"]
                args = tool["args"]
                await self.remove_tool(name)
                await self.add_tool(name, command, args)
                process = self.tools[name]["process"]

            # Prepare request
            request = json.dumps(params) + "\n"

            # Send request to stdin
            process.stdin.write(request.encode())
            await process.stdin.drain()

            # Read response from stdout
            response_line = await process.stdout.readline()

            if not response_line:
                return {"status": "error", "message": "Empty response from tool"}

            # Parse JSON response
            try:
                response = json.loads(response_line)
                return response
            except json.JSONDecodeError:
                return {
                    "status": "error",
                    "message": f"Invalid JSON response: {response_line.decode('utf-8')}"
                }

        except Exception as e:
            logger.error(f"Failed to invoke tool {name}: {str(e)}")
            return {"status": "error", "message": f"Failed to invoke tool: {str(e)}"}
